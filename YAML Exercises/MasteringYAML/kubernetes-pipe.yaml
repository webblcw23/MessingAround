# taking the previous example and adding a full CI/CD pipeline for a .NET web application. We are encorparating AKS to do the deployment for us.
# Prerequisites: We need to have a dockerfile in the source code, a Kubernetes cluster set up, and Azure CLI installed on the agent.

trigger:
  branches:
    include:
      - main

pool:
  vmImage: "ubuntu-latest" # AKS and Docker work best on Linux agents

variables:
  buildConfiguration: "Release"
  sourceFolder: "src/MyWebApp"
  publishFolder: "$(Build.ArtifactStagingDirectory)"
  artifactName: "drop"
  azureSubscription: "My Azure Subscription"
  devEnvironmentName: "Dev"
  uatEnvironmentName: "UAT"
  acrName: "youracr.azurecr.io"
  imageName: "mywebapp"
  imageTag: "$(Build.BuildId)"
  aksResourceGroup: "your-rg" # Resource group containing the AKS cluster
  aksClusterName: "your-aks-cluster" # Name of the AKS cluster
  kubernetesNamespaceDev: "dev"
  kubernetesNamespaceUat: "uat"
  dockerfilePath: "$(sourceFolder)/Dockerfile" # Path to the Dockerfile in the source code

stages:
  - stage: Build
    displayName: "Build and Push Docker Image"
    jobs:
      - job: BuildJob
        displayName: "Build and Push"
        steps:
          - task: UseDotNet@2
            inputs:
              packageType: "sdk"
              version: "8.0.x"

          - script: dotnet restore $(sourceFolder)
            displayName: "Restore NuGet Packages"

          - script: dotnet build $(sourceFolder) --configuration $(buildConfiguration)
            displayName: "Build Solution"

          - script: dotnet test tests/MyWebApp.Tests/MyWebApp.Tests.csproj --configuration $(buildConfiguration) --no-build
            displayName: "Run Unit Tests"

          - task: Docker@2 # Build and push Docker image
            inputs:
              containerRegistry: "$(acrName)" # Azure Container Registry
              repository: "$(imageName)" # Name of the Docker image
              command: "buildAndPush" # Build and push command
              Dockerfile: "$(dockerfilePath)" #
              tags: |
                $(imageTag)
            displayName: "Build and Push Docker Image"

  - stage: ReleaseToDev
    displayName: "Deploy to AKS Dev"
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployToDev
        displayName: "Deploy to AKS Dev"
        environment: "$(devEnvironmentName)"
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureCLI@2 # Azure CLI task to deploy to AKS. See inline script below
                  inputs:
                    azureSubscription: "$(azureSubscription)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName)
                      kubectl create namespace $(kubernetesNamespaceDev) --dry-run=client -o yaml | kubectl apply -f -
                      kubectl apply -f k8s/deployment.yaml -n $(kubernetesNamespaceDev)
                      kubectl apply -f k8s/service.yaml -n $(kubernetesNamespaceDev)
                  displayName: "Deploy to AKS Dev"

  - stage: ReleaseToUat
    displayName: "Deploy to AKS UAT"
    dependsOn: ReleaseToDev
    condition: succeeded()
    jobs:
      - deployment: DeployToUat
        displayName: "Deploy to AKS UAT"
        environment: "$(uatEnvironmentName)"
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureCLI@2 # Azure CLI task to deploy to AKS. See inline script below
                  inputs:
                    azureSubscription: "$(azureSubscription)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName)
                      kubectl create namespace $(kubernetesNamespaceUat) --dry-run=client -o yaml | kubectl apply -f -
                      kubectl apply -f k8s/deployment.yaml -n $(kubernetesNamespaceUat)
                      kubectl apply -f k8s/service.yaml -n $(kubernetesNamespaceUat)
                  displayName: "Deploy to AKS UAT"
# Now the .net application is built, tested, and deployed to AKS in two stages: Dev and UAT.

# #Tpyical dockerfile for .net application

# Stage 1: Build
# FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
# WORKDIR /app

# #Copy csproj and restore as distinct layers
# COPY *.sln .
# COPY src/MyWebApp/*.csproj ./src/MyWebApp/
# RUN dotnet restore ./src/MyWebApp/MyWebApp.csproj

# #Copy everything else and build
# COPY . .
# RUN dotnet publish ./src/MyWebApp/MyWebApp.csproj -c Release -o /app/publish

# Stage 2: Runtime
# FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
# WORKDIR /app
# COPY --from=build /app/publish .

# #Optional: expose port (default is 80)
#  EXPOSE 80

# #Start the app
# ENTRYPOINT ["dotnet", "MyWebApp.dll"]
#
